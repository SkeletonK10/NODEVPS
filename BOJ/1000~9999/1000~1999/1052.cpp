#include <bits/stdc++.h>
#define FastIO ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

using namespace std;

void solve() {
  int n, k;
  cin >> n >> k;
  int b = 0;

  // 모든 물병의 크기는 1에서 시작 -> 합칠 때 2^n꼴이 제일 이득
  // 일단 모두 합쳤다고 가정할 때 물병의 개수와 크기는 2진수로 나타남
  // 물이 많이 들어있는 곳은 최대한 놔두고, 작은 것들을 합치는 것이 이득
  for (int i = 23;i >= 0;i--) {  // 2^24-1 = 16777215 > 10^7

    // 물병의 개수를 큰 것 부터 센다
    b += ( n >> i ) & 1;

    // 센 물병의 개수가 k개가 되었을 때. 이보다 작은 물병은 다 합쳐야 함
    // 밑의 물병을 다 합쳐서 2^i가 되게끔 해야 함 (그래야 k개, 혹은 더 적게 남길 수 있음)
    if (b == k) {

      // 000001111111 꼴
      int l = ( 1 << i ) - 1;

      // ?? 이해가 안 되는 부분. ( ( ( ~n & l ) + 1 ) & l ) 이 뭔데?

      // n과 NOT n을 더하면 111111 꼴이 나온다.
      // 이때 1을 더하면 1000000 꼴, 우리가 원하는 2^i를 얻을 수 있음.
      // 즉 우리가 n을 가지고 있을 때, 사야 하는 물병은 NOT n + 1 개.

      // ~n & l = NOT n 중에서 밑의 몇 자리만 떼 놓은 형태. 우리는 2^i를 원하기에 몇 자리만 뗀다.
      // 1을 더하면 2^i꼴을 위해 필요한 물병 수가 됨.

      // 중요한 특수 케이스: k개 밑에 아무것도 없을 때. (k=3일 때 1101000 같은 느낌) 정답은 0이다.
      // 이때 (~n&l)+1 의 값은 2^i가 된다. 정답이 아님.
      // 이 케이스를 해결하기 위해 마지막에 l로 다시 필터링해 줌.
      cout << ( ( ( ~n & l ) + 1 ) & l );
      return;
    }
  }
  cout << 0;
}

int main() {
  FastIO;
  int testcase = 1;
  //cin >> testcase;
  for (int tc = 1;tc <= testcase;tc++) {
    solve();
  }
}
